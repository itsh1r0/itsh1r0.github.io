<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VN Style Portfolio</title>
  <link rel="icon" href="./assets/GameIcon.png" type="image/x-icon">
  <link rel="preload" href="./assets/cg_0.png" as="image">
  <link rel="preload" href="./assets/cg_1.png" as="image">
  <link rel="preload" href="./assets/cg_2.png" as="image">
  <link rel="preload" href="./assets/cg_3.png" as="image">
  <link rel="preload" href="./assets/cg_4.png" as="image">
  <link rel="preload" href="./assets/cg_5.png" as="image">
  <link rel="preload" href="./assets/cg_6.png" as="image">
  <link rel="preload" href="./assets/cg_7.png" as="image">
  <link rel="preload" href="./assets/cg_8.png" as="image">
  <link rel="preload" href="./assets/cg_9.png" as="image">
  <link rel="preload" href="./assets/cg_a.png" as="image">
  <link rel="preload" href="./assets/cg_b.png" as="image">
  <link rel="preload" href="./assets/cg_c.png" as="image">
  <link rel="preload" href="./font/MainDialoge SDF.ttf" as="font" type="font/ttf" crossorigin>
  <link rel="stylesheet" href="./styles.css">
</head>
<body onload="initApp()">
  <div id="fade-overlay"></div>
  <div id="preloader">
    <img id="loading-img" src="" alt="Loading...">
    <p>NOW LOADING...</p>
  </div>
  <div id="dialog-box">
    <div id="character-name">Lilith</div>
    <div id="dialog-container">
      <div id="dialog-text">This is a sample dialog text.</div>
    </div>
    <div id="choices-container"></div> <!-- Thêm dòng này -->
  </div>
  <div id="volume-slider">
    <img src="./assets/slider.png" class="slider-track" draggable="false">
    <div class="slider-full-clip">
      <img src="./assets/slider_full.png" class="slider-full" draggable="false">
    </div>
    <img src="./assets/slider_handle.png" class="slider-handle" id="slider-handle" draggable="false">
  </div>
  <audio id="bgm" src="./assets/Waterdrop.mp3" loop></audio>
  <script defer>
    const loadingImgs = ["./assets/Load1.png", "./assets/Load2.png", "./assets/Load3.png"];
    const selectedLoadingImg = loadingImgs[Math.floor(Math.random() * loadingImgs.length)];
    let dialogs = [];
    let currentDialogIndex = 0;
    let isPreloading = true;
    let isFading = false;

    async function loadDialogs(file = "prologue.json") {
      const res = await fetch(file);
      dialogs = await res.json();
      currentDialogIndex = 0;
      updateDialog();
    }

    async function initApp() {
      // Hiển thị preloader với nền đen
      document.body.style.backgroundColor = "#000";
      document.getElementById("preloader").style.display = "flex";

      // Load hình ảnh loading
      const img = new Image();
      img.src = selectedLoadingImg;
      await new Promise(resolve => img.onload = resolve);
      document.getElementById("loading-img").src = selectedLoadingImg;

      // Preload tất cả tài nguyên
      const preloadPromise = Promise.all([
        ...["./assets/cg_0.png",
            "./assets/cg_1.png",
            "./assets/cg_2.png",
            "./assets/cg_3.png",
            "./assets/cg_4.png",
            "./assets/cg_5.png",
            "./assets/cg_6.png",
            "./assets/cg_7.png",
            "./assets/cg_8.png",
            "./assets/cg_9.png",
            "./assets/cg_a.png",
            "./assets/cg_b.png",
            "./assets/cg_c.png"].map(src => {
          return new Promise(resolve => {
            const asset = new Image();
            asset.src = src;
            asset.onload = resolve;
          });
        }),
        fetch("./font/MainDialoge SDF.ttf")
      ]);

      const minimumTime = new Promise(resolve => setTimeout(resolve, 3000));
      await Promise.all([preloadPromise, minimumTime]);

      // Load dialogs trước khi truy cập dialogs[0]
      await loadDialogs();

      // Chuyển sang background đầu tiên sau khi preload hoàn thành
      document.body.style.backgroundImage = `url('${dialogs[0].background}')`;
      document.body.style.backgroundSize = "cover";
      document.body.style.backgroundPosition = "center";
      document.body.style.backgroundRepeat = "no-repeat";

      // Ẩn preloader và hiển thị dialog box
      document.getElementById("preloader").style.display = "none";
      document.getElementById("dialog-box").style.display = "block";
      document.getElementById("volume-slider").style.display = "block"; // Thêm dòng này
      isPreloading = false;

      // Phát nhạc nền sau khi preload xong
      const bgm = document.getElementById("bgm");
      if (bgm) {
        try {
          await bgm.play();
        } catch (e) {
          // Một số trình duyệt yêu cầu tương tác người dùng mới phát nhạc
          // Có thể xử lý ở đây nếu muốn
        }
      }
    }

    function setFade(active, instant = false) {
      const overlay = document.getElementById("fade-overlay");
      overlay.style.transition = instant ? "none" : "opacity 1s";
      if (active) {
        overlay.classList.add("active");
        isFading = true;
      } else {
        overlay.classList.remove("active");
        isFading = false;
      }
    }

    async function updateDialog() {
      const currentDialog = dialogs[currentDialogIndex];
      const choicesContainer = document.getElementById("choices-container");

      if (currentDialog.fade) {
        // Đổi background và text TRƯỚC khi fade
        document.body.style.backgroundImage = `url('${currentDialog.background}')`;
        document.getElementById("character-name").textContent = currentDialog.character;
        document.getElementById("dialog-text").textContent = currentDialog.text;

        // Hiện overlay đen hoàn toàn (không transition)
        setFade(true, true);
        await new Promise(r => setTimeout(r, 1000)); // 1s đen ngòm

        // Dần hiện ra trong 1s
        setFade(false, false); // transition 1s
        isFading = true;
        await new Promise(r => setTimeout(r, 1000));
        isFading = false;

        // Sau khi fade xong, tự động sang hội thoại tiếp theo
        currentDialogIndex++;
        if (currentDialogIndex < dialogs.length) {
          updateDialog();
        }
        return;
      } else {
        document.body.style.backgroundImage = `url('${currentDialog.background}')`;
        document.getElementById("character-name").textContent = currentDialog.character;
        document.getElementById("dialog-text").textContent = currentDialog.text;
      }

      // Nếu có trường next và không có choices, tự động chuyển file
      if (currentDialog.next && !currentDialog.choices) {
        loadDialogs(currentDialog.next);
        return;
      }

      choicesContainer.innerHTML = "";
      if (currentDialog.choices) {
        choicesContainer.style.display = "flex";
        currentDialog.choices.forEach(choice => {
          const btn = document.createElement("button");
          btn.textContent = choice.text;
          btn.className = "choice-btn";
          btn.onclick = async (e) => {
            e.stopPropagation();
            await loadDialogs(choice.next);
          };
          choicesContainer.appendChild(btn);
        });
      } else {
        choicesContainer.style.display = "none";
      }
    }

    // Ngăn click khi đang fade
    document.addEventListener("mousedown", function(e) {
      // Không chuyển hội thoại nếu đang fade, preload, hoặc click vào slider
      if (
        isFading ||
        isPreloading ||
        dialogs.length === 0 ||
        dialogs[currentDialogIndex].choices ||
        currentDialogIndex >= dialogs.length - 1 ||
        e.target.closest('#volume-slider')
      ) {
        return;
      }
      currentDialogIndex++;
      updateDialog();
    });

    const slider = document.getElementById('volume-slider');
    const sliderHeight = 400; // px
    const handleHeight = 16;  // px (đúng kích thước ảnh handle)
    const VOLUME_MIN = 0;
    const VOLUME_MAX = 1.0;
    let volume = 0.7;

    const sliderHandle = document.getElementById('slider-handle');
    const sliderFullClip = document.querySelector('.slider-full-clip');
    const sliderFullImg = sliderFullClip.querySelector('.slider-full');

    function setVolumeSlider(vol) {
      volume = Math.max(VOLUME_MIN, Math.min(VOLUME_MAX, vol));
      const percent = volume / VOLUME_MAX;

      // Handle vị trí
      const handleY = (1 - percent) * (sliderHeight - handleHeight);
      sliderHandle.style.top = `${handleY}px`;

      // Phần đầy: crop phần trên, giữ phần dưới
      const visibleHeight = percent * sliderHeight;
      sliderFullClip.style.height = `${visibleHeight}px`;
      sliderFullClip.style.bottom = '0';
      sliderFullImg.style.bottom = '0';
      sliderFullImg.style.top = 'auto';
      sliderFullImg.style.transform = 'none';

      // Volume audio
      const bgm = document.getElementById('bgm');
      if (bgm) bgm.volume = volume;
    }

    // Khởi tạo vị trí ban đầu
    setVolumeSlider(volume);

    // Kéo handle
    let dragging = false;
    let skipNextClick = false;

    sliderHandle.addEventListener('mousedown', function(e) {
      dragging = true;
      document.body.style.userSelect = 'none';
      // Ngăn trình duyệt tạo click sau mouseup
      e.preventDefault();
    });

    document.addEventListener('mouseup', function(e) {
      if (dragging) {
        dragging = false;
        skipNextClick = true; // Đánh dấu phải bỏ qua click tiếp theo
        document.body.style.userSelect = '';
        // Ngăn trình duyệt tạo click sau mouseup
        e.preventDefault && e.preventDefault();
      }
    });

    document.addEventListener('click', function(e) {
      if (skipNextClick) {
        skipNextClick = false;
        e.stopPropagation && e.stopPropagation();
        e.preventDefault && e.preventDefault();
        return;
      }
      // ...xử lý chuyển hội thoại như cũ...
    });

    document.addEventListener('mousemove', function(e) {
      if (!dragging) return;
      const rect = slider.getBoundingClientRect();
      let y = e.clientY - rect.top;
      y = Math.max(0, Math.min(sliderHeight - handleHeight, y));
      const percent = 1 - y / (sliderHeight - handleHeight);
      setVolumeSlider(percent * VOLUME_MAX);
    });

    let lastSliderClick = 0;
    const DEFAULT_VOLUME = 0.7;

    // Click vào slider để chỉnh nhanh
    slider.addEventListener('click', function(e) {
      e.stopPropagation();
      const now = Date.now();
      if (now - lastSliderClick < 150) { // 0.15s
        setVolumeSlider(DEFAULT_VOLUME);
      } else {
        const rect = slider.getBoundingClientRect();
        let y = e.clientY - rect.top;
        y = Math.max(0, Math.min(sliderHeight - handleHeight, y));
        const percent = 1 - y / (sliderHeight - handleHeight);
        setVolumeSlider(percent * VOLUME_MAX);
      }
      lastSliderClick = now;
    });

    // Khởi tạo vị trí ban đầu (70%)
    setVolumeSlider(0.7);
  </script>
</body>
</html>